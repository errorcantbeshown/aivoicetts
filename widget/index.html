<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, shrink-to-fit=no">
        <title>AI Voice TTS - Widget</title>

        <!-- Favicon -->
        <link rel="icon" type="image/png" href="../assets/images/logo/favicon_120x120.png">
        <link rel="apple-touch-icon" href="../assets/images/logo/favicon_120x120.png">

        <!-- page css -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/select2-bootstrap-5-theme@1.3.0/dist/select2-bootstrap-5-theme.min.css" />
        
        <!-- Core css -->
        <link href="../assets/css/app.min.css" rel="stylesheet">
        <link rel="stylesheet" media="all" type="text/css" href="../assets/vendors/fontawesome/css/font-awesome-5-all.min.css" />
        
        <!-- page js -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>

        <!-- custom css -->
        <style>
            html, body {
                background-color: transparent;
                overflow-x: hidden;
            }
            #alertBox {
                opacity: 1;
                transition: opacity 1s; 
            }
            #alertBox.fade {
                opacity: 0;
            }
            .normalTTSBackground {
                background: url('../assets/images/rgb-audio-wave-animation.gif') center no-repeat transparent;
                background-size: cover;
            }
            .juliBanTTSBackground {
                background: url('../assets/images/rear-view-of-police-cars-chasing.gif') center no-repeat transparent;
                background-size: cover;
            }
        </style>
    </head>

    <body>
        <!-- Loading START -->
        <div id="page-loading" class="d-none align-items-center justify-content-center position-absolute w-100 h-100" style="z-index:3000;">
            <div class="spinner-border" role="status">
                <span class="sr-only">Loading...</span>
            </div>
        </div>
        <!-- Loading END -->

        <!-- Content START -->
        <div id="page-content">
            <div class="normalTTSBackground fade" id="alertBox" style="width: 100%;height: 100vw;">
                <div class="row d-flex justify-content-center align-items-center bd-highlight h-100">
                    <font class="text-center text-white" id="speechText" style="text-shadow: rgb(0, 0, 0) 3px 3px 0px, rgb(0, 0, 0) -1px -1px 0px, rgb(0, 0, 0) 1px -1px 0px, rgb(0, 0, 0) -1px 1px 0px, rgb(0, 0, 0) 1px 1px 0px;">[Speech Text Goes Here]</font>
                </div>
            </div>
        </div>
        <!-- Content END -->

        <!-- Core Vendors JS -->
        <script src="../assets/js/vendors.min.js"></script>
        
        <!-- page js -->
        <script async defer src="https://apis.google.com/js/api.js"></script>
        
        <!-- Core JS -->
        <script src="../assets/js/app.min.js"></script>

        <!-- Custom JS -->
        <script src='https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js' type='text/javascript'></script>
        <script type="text/javascript">
            
            // Initialize Global Variables
            var appID = null;
            var developerKey = null;
            var userInfoSheetID = null;
            var adminAccessToken = null;
            var userInfoValues = null;
            var userID = null;
            var userName = null;
            var userSLToken = null;
            var userELToken = null;
            var userOAToken = null;
            var userBotBackgroundImageURL = "../assets/images/bot-butler_placeholder.png";
            var userBotInstructions = "";
            var cheerWords;
            var twitchUserName = "Anonymous";
            
            const alertAudioSource = "../assets/audio/twitch-bits-donation-sound-effect-sfx.mp3";

            var isBot = false;
            const fillerAudioList = [
                {entry: "../assets/audio/filler/knocking-and-door-opening.mp3", percentage: 50},
                {entry: "../assets/audio/filler/three-gentle-knocks.mp3", percentage: 30},
                {entry: "../assets/audio/filler/throat-clear-with-spoken-knock.mp3", percentage: 20}
            ];
            const fillerAudios = createPercentageBasedArray(fillerAudioList);
            var endingDialogue = "";
            
            var voices;
            var allVoiceNames;
            var unrestrictedVoiceNames;
            var standardVoiceNames;
            const premiumVoiceBitsAmount = 500;
            var voiceVolume = 1.0;

            // Prep Event Queue
            const eventQueue = [];
            let isProcessing = false;

            function processEventQueue() {
                if (isProcessing || eventQueue.length === 0) {
                    return;
                }

                isProcessing = true;
                const event = eventQueue.shift();
                handleEvent(event);
            }

            function handleEvent(event) {
                return new Promise((resolve, reject) => {
                    try {
                        // Here you could add more event handling functions as needed
                        Promise.all([
                            handleStreamLabsTwitchEvent(event)
                            // Add other functions if you have more event types
                        ]).then(resolve).catch(reject);
                    } catch (error) {
                        reject(error);
                        endProcessing();
                    }
                });
            }

            function endProcessing() {
                isProcessing = false;
                processEventQueue(); // Process the next event in the queue
            }
            
            $(document).ready(function() {
                processSpeechText();
                window.addEventListener('resize', processSpeechText);

                const urlParams = new URLSearchParams(window.location.search);
                const userID = urlParams.get('u') || null;

                if (!userID) {
                    console.error('Invalid or missing User ID.');
                    alert('Error 400.');
                    return;
                }

                // Show/hide loading animation on page load/unload
                window.onpageshow = () => toggleLoadingDisplay(false);
                window.onbeforeunload = () => toggleLoadingDisplay(true);

                loadJSONFiles([
                    '../voices.json',
                    '../settings.json'
                ]).then(([voicesData, settingsData]) => {
                    setupVoiceData(voicesData);
                    processAppSettings(settingsData);
                }).catch(err => {
                    console.error('Error loading JSON files:', err);
                    alert('App Settings Error!');
                });

                function toggleLoadingDisplay(isLoading) {
                    $("#page-content").toggle(!isLoading);
                    $("#page-loading").toggleClass("d-flex", isLoading).toggleClass("d-none", !isLoading);
                }

                async function loadJSONFiles(paths) {
                    return await Promise.all(paths.map(path => $.getJSON(path)));
                }

                function setupVoiceData(data) {
                    voices = data;
                    allVoiceNames = Object.keys(voices);
                    unrestrictedVoiceNames = allVoiceNames.filter(name => name !== "butler");
                    standardVoiceNames = unrestrictedVoiceNames.filter(name => name !== "mayor");
                }

                function processAppSettings(data) {
                    appID = data.googleCloudAppCredentials.appID;
                    developerKey = data.googleCloudAppCredentials.apiKey;
                    userInfoSheetID = data.googleDriveDataLocations.userInfoSheetID;
                    cheerWords = data.appValues.cheerWords;

                    await manageAccessToken(data.googleCloudAppCredentials.client_id, data.googleCloudAppCredentials.client_secret, data.googleCloudAppCredentials.refresh_token).then(() => {
                        loadSheetReadingClient();
                    }).catch(err => {
                        console.error('Unable to retrieve or refresh Access Token.', err);
                    });
                }

                async function manageAccessToken(client_id, client_secret, refresh_token) {
                    let expiration = parseInt(sessionStorage.getItem("adminAccessTokenExpiration"));
                    const isTokenExpired = (Date.now() / 1000) > (expiration - 300);

                    if (isTokenExpired) {
                        console.log('Refreshing Access Token...');
                        const newTokenData = await refreshAccessToken(client_id, client_secret, refresh_token);
                        adminAccessToken = newTokenData.access_token;
                        sessionStorage.setItem("adminAccessToken", adminAccessToken);
                        sessionStorage.setItem("adminAccessTokenExpiration", (Date.now() / 1000) + newTokenData.expires_in);
                    } else {
                        adminAccessToken = sessionStorage.getItem("adminAccessToken");
                    }
                }
            });

            function refreshAccessToken(clientID, clientSecret, refreshToken) {
                return new Promise(function(resolve, reject) {
                    $.ajax({
                        url: 'https://accounts.google.com/o/oauth2/token',
                        data: {
                            client_id: clientID,
                            client_secret: clientSecret,
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        },
                        type: 'POST',
                        dataType: 'json',
                        success: function(responseData) {
                            resolve(responseData);
                        },
                        error: function(err) {
                            reject(err);
                        }
                    });
                });
            }

            function loadSheetReadingClient() {
                gapi.load('client', initializeSheetReadingClient);
            }
            
            function initializeSheetReadingClient() {
                gapi.client.init({
                    apiKey: developerKey,
                    discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
                }).then(() => {
                    console.log('Reading database...');
                    getUserInfo(userID);
                });
            }

            // Searches for User ID in database and sets user info variables
            function getUserInfo(userID) {
                gapi.client.request({
                    path: 'https://content-sheets.googleapis.com/v4/spreadsheets/' + userInfoSheetID + '/values/Sheet1!A2:G',
                    method: 'GET',
                    headers: {
                        Authorization: 'Bearer ' + adminAccessToken,
                    },
                }).then((response) => {
                    const values = response.result.values;
                    if (values && values.length > 0) {
                        console.log('Database read successfully!');

                        var userInfoIndex = findIndex(values, userID);
                        if (userInfoIndex[0] != -1 && userInfoIndex[1] == 0) {
                            console.log('User Info found!');
                            userInfoValues = [ values[userInfoIndex[0]][0], values[userInfoIndex[0]][1], values[userInfoIndex[0]][2], values[userInfoIndex[0]][3], values[userInfoIndex[0]][4], values[userInfoIndex[0]][5], values[userInfoIndex[0]][6] ];
                            userName = userInfoValues[1];
                            userSLToken = userInfoValues[2];
                            userELToken = userInfoValues[3];
                            userOAToken = userInfoValues[4];
                            userBotInstructions = userInfoValues[6];

                            // Bot Background Image
                            if (userInfoValues[5]) { userBotBackgroundImageURL = userInfoValues[5]; }
                            addBotBackgroundCSS('butler', userBotBackgroundImageURL);

                            // Connect to socket
                            const streamlabs = io(`https://sockets.streamlabs.com?token=${userSLToken}`, {transports: ['websocket']});
                            console.log('Listening on Streamlabs...');

                            // Perform Action on event
                            streamlabs.on('event', (eventData) => {
                                if (eventData.for === 'twitch_account') {
                                    eventQueue.push(eventData);
                                    processEventQueue(); // Start processing the queue
                                }
                            });
                        } else {
                            // Handle the case were no match is found in the first column
                            console.error('User not found! Index: ' + userInfoIndex);
                            alert('Database Error 404.');
                        }
                    } else {
                        console.error('No values found!');
                        alert('Database Error 204.');
                    }
                }).catch((error) => {
                    console.error('Error reading values:', error);
                    alert('Database Error 500.');
                });
            }

            // Method to return an array of indices of keyString
            function findIndex(stringArray, keyString) {
                // Initialising result array to -1 in case keyString is not found
                let result = [-1, -1];
            
                // Iteration over all the elements of the 2-D array
            
                // Rows
                for (let r = 0; r < stringArray.length; r++) {
            
                    // Columns
                    for (let c = 0; c < stringArray[r].length; c++) {
            
                        // If keyString is found
                        if (stringArray[r][c] == keyString) {
                            result[0] = r;
                            result[1] = c;
                            return result;
                        }
                    }
                }
            
                // If keyString is not found then -1 is returned
                return result;
            }

            function handleStreamLabsTwitchEvent(eventData) {
                return new Promise((resolve, reject) => {
                    try {
                        //console.log(JSON.stringify(eventData));
                        if (eventData.type == "bits") {
                            console.log("Twitch Bits/Cheer Event!");
                            isBot = false;

                            // Save Username of Cheerer
                            twitchUserName = eventData.message[0]?.name || "Anonymous";

                            // Check if Preview or Test Alert
                            const isPreview = eventData.message[0]?.isPreview || false;
                            const isTest = eventData.message[0]?.isTest || false;

                            if (!isPreview) {
                                const bitsAmount = parseInt(eventData.message[0]?.amount) || 0;
                                if (isTest) {
                                    console.log("Received Test Alert.");
                                    console.log(eventData.message);
                                    if (bitsAmount >= premiumVoiceBitsAmount) {
                                        resolveCheerAlertTTS(bitsAmount, "[mayor] " + eventData.message[0].message.replace(/"/g, ''));
                                    } else if (parseInt(eventData.message[0].amount) >= 1) {
                                        resolveCheerAlertTTS(bitsAmount, "[hifumi] " + eventData.message[0].message.replace(/"/g, ''));
                                    }
                                } else {
                                    if (bitsAmount >= 1) {
                                        resolveCheerAlertTTS(bitsAmount, eventData.message[0].message.replace(/"/g, ''));
                                    }
                                }
                            }
                            resolve(`Bits Event processed for ${twitchUserName}`);
                        } else if (eventData.type == "subscription" || eventData.type == "resub") {
                            console.log("Twitch Sub Event!");
                            // Save Username of Subscriber
                            twitchUserName = eventData.message[0]?.name || "Anonymous";
                            try {
                                if (eventData.message[0].message) {
                                    isBot = false;
                                    setTimeout(function() {
                                        resolveSubAlertTTS(eventData.message[0].message);
                                    }, 3000);
                                } else {
                                    if (eventData.message[0].subscriber_name) {
                                        console.log("Triggered from Mass Gifting. Ignoring...");
                                        endProcessing();
                                    } else {
                                        if (eventData.message[0].gifter) {
                                            console.log("Single Gifted Sub! Activating Bot...");
                                            isBot = true;
                                            setTimeout(function() { prepForBot() }, 3000);

                                            sendMessageToBot("\"" + eventData.message[0].gifter + "\" just gifted a Twitch sub to \"" + twitchUserName + "\"");
                                        } else {
                                            console.log("No Sub Message. Activating Bot...");
                                            isBot = true;
                                            setTimeout(function() { prepForBot() }, 3000);

                                            let months = parseInt(eventData.message[0].months);
                                            sendMessageToBot("\"" + twitchUserName + "\" just " + (months > 0 ? "resubscribed on Twitch" : "subscribed on Twitch for the very first time"));
                                        }
                                    }
                                }
                            } catch (err) {
                                console.log("Unable to read message from Event.", err);
                                endProcessing();
                            }
                            resolve(`Sub Event processed for ${twitchUserName}`);
                        } else if (eventData.type == "subMysteryGift") {
                            console.log("Twitch Mass Gifted Sub Event! Activating Bot...");
                            try {
                                isBot = true;
                                setTimeout(function() { prepForBot() }, 3000);

                                let amount = parseInt(eventData.message[0].amount);
                                sendMessageToBot("\"" + eventData.message[0].gifter + "\" just gifted " + eventData.message[0].amount + " Twitch sub" + (amount == 1 ? "" : "s") + " to the community");
                            } catch (err) {
                                console.log("Unable to activate.", err);
                                endProcessing();
                            }
                            resolve(`Sub Event processed`);
                        } else {
                            // Failsafe?
                            resolve("Do Nothing.");
                            endProcessing();
                        }
                    } catch (error) {
                        reject(error);
                        endProcessing();
                    }
                });
            }

            function resolveCheerAlertTTS(bitsAmount, bitsMessage) {
                // Retrieve Voice Name from the Bits Message
                var voiceName = extractVoiceName(bitsMessage);
                
                // Set the available Voice Names based on Bits Amount
                var availableVoiceNames = (bitsAmount >= premiumVoiceBitsAmount ? unrestrictedVoiceNames : standardVoiceNames);
                    
                // Initialize Necessary Variables for Voice
                var voiceID = null;
                var voiceSettings = "";
                var modelID = "";

                // Perform Voice Name checks and Voice Retrieval if not "juli"
                if (voiceName != "juli") {
                    var voice;
                    
                    // Check if Voice Name is an available choice or "random" 
                    if (voiceName == "random") {
                        voiceName = availableVoiceNames[(Math.floor(Math.random() * availableVoiceNames.length))];
                        voice = voices[voiceName];
                    } else if (!availableVoiceNames.includes(voiceName)) {
                        console.log("Voice Name \"" + voiceName + "\" NOT an available choice.")
                        voice = voices["will"];
                    } else { voice = voices[voiceName]; }
                    
                    // Set Voice values accordingly
                    voiceID = voice.voice_id;
                    voiceSettings = voice.voice_settings;
                    modelID = voice.model_id;
                    voiceVolume = voice.voice_volume;

                    // If Voice has different dialogue endings, add one to the end of the Message
                    if (voice.dialogue_endings.length != 0) {
                        endingDialogue = voice.dialogue_endings[(Math.floor(Math.random() * voice.dialogue_endings.length))];
                        bitsMessage += endingDialogue;
                    }
                } else { voiceID = voiceName; }
                
                // Check Voice ID
                if (voiceID) {
                    // Remove any cheers and voice name (including brackets) from the bits message
                    let voiceText = removeCheerWords(bitsMessage).replace('[' + voiceName + ']','').replace('[random]','').trim();

                    if (voiceText) {
                        // Convert the above text to speech using the indicated voice
                        initiateTTS(true, voiceID, voiceSettings, voiceText, modelID);
                    } else {
                        // Handle the case where there is no message
                        console.log("No message for TTS.");
                        endProcessing();
                    }
                } else {
                    // Handle the case where name matches no id
                    console.error("No ID found for voice name.");
                    endProcessing();
                }
            }

            function extractVoiceName(message) {
                const match = message.match(/\[([^\]]+)\]/);
                return match ? match[1].toLowerCase() : "default";
            }

            function removeCheerWords(eventMessage) {
                // Create a regex to match any cheer words followed by digits
                const regex = new RegExp(cheerWords.map(word => `${word}\\d+`).join('|'), 'gi');
                return eventMessage.replace(regex, '');
            }

            function prepForBot() {
                try {
                    speechText.innerHTML = "";
                    processSpeechText();
                    changeSpeechTextContainerBackround('normal', 'butler');
                    speechTextContainer.classList.toggle('fade');
                    
                    // Play Bot Filler Audio
                    var fillerAudio = new Audio(fillerAudios[(Math.floor(Math.random() * fillerAudios.length))]);
                    fillerAudio.play();
                } catch (error) { console.error(error); }
            }

            async function sendMessageToBot(message) {
                const apiUrl = "https://api.openai.com/v1/chat/completions";
                const headers = {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${userOAToken}`
                };

                const data = {
                    model: "gpt-4o",
                    messages: [
                        { role: "system", content: userBotInstructions },
                        { role: "user", content: message }
                    ]
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: headers,
                        body: JSON.stringify(data)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Error: ${response.status}`);
                    }

                    const responseData = await response.json();

                    // Remove any quotation marks and replace line breaks with spaces to prevent any TTS issues
                    resolveSubAlertTTS("[butler] " + responseData.choices[0].message.content.replace(/"/g, '').replace(/\n/g, " "));
                } catch (error) {
                    console.error("Error sending message: ", error);
                    endProcessing();
                }
            }
            
            const speechText = document.getElementById('speechText');
            const speechTextContainer = document.getElementById('alertBox');

            function initiateTTS(playAlertAudio, voiceID, voiceSettings, voiceText, modelID) {

                if (voiceID == "juli") {
                    speechText.innerHTML = "Time to ban " + twitchUserName + "!";
                    processSpeechText();
                    changeSpeechTextContainerBackround('normal', 'juliBan');
                    speechTextContainer.classList.toggle('fade');
                    if (playAlertAudio) {
                        var alertAudio = new Audio(alertAudioSource);
                        alertAudio.addEventListener("ended", function() {
                            playTTSAudio('../assets/audio/juli_yeah-thats-a-ban.mp3', true, 'juliBan', 'normal');
                        });
                        var alertPlayPromise = alertAudio.play();
                        if (alertPlayPromise !== undefined) {
                            alertPlayPromise.then(_ => {
                                // Autoplay started!
                            }).catch(error => {
                                // Autoplay was prevented.
                                console.error(error);
                                speechTextContainer.classList.toggle('fade');
                                setTimeout(function() {
                                    changeSpeechTextContainerBackround('juliBan', 'normal');
                                    endProcessing();
                                }, 1000);
                            });
                        }
                    } else { playTTSAudio('../assets/audio/juli_yeah-thats-a-ban.mp3', true, 'juliBan', 'normal'); }
                } else {
                    // Build options array needed for Elevenlabs API request
                    var elevenlabsOptions = {
                        method: 'POST',
                        headers: {
                            'xi-api-key': userELToken,
                            'Content-Type': 'application/json'
                        },
                        body: '{"voice_settings":' + voiceSettings + ',"text":"' + voiceText + '","model_id":"' + modelID + '"}'
                    };
                
                    fetch('https://api.elevenlabs.io/v1/text-to-speech/' + voiceID + '?enable_logging=false', elevenlabsOptions)
                        .then(res => res.blob())
                        .then(blob => {
                            speechText.innerHTML = voiceText.replace(endingDialogue,'');
                            processSpeechText();
                            if (!isBot) { speechTextContainer.classList.toggle('fade'); }
                            if (playAlertAudio) {
                                var alertAudio = new Audio(alertAudioSource);
                                alertAudio.addEventListener("ended", function() {
                                    const url = URL.createObjectURL(blob);
                                    if (isBot) { playTTSAudio(url, true, 'butler', 'normal'); }
                                    else { playTTSAudio(url, false, null, null); }
                                });
                                var alertPlayPromise = alertAudio.play();
                                if (alertPlayPromise !== undefined) {
                                    alertPlayPromise.then(_ => {
                                        // Autoplay started!
                                    }).catch(error => {
                                        // Autoplay was prevented.
                                        console.error(error);
                                        speechTextContainer.classList.toggle('fade');
                                        endProcessing();
                                    });
                                }
                            } else {
                                const url = URL.createObjectURL(blob);
                                if (isBot) { playTTSAudio(url, true, 'butler', 'normal'); }
                                else { playTTSAudio(url, false, null, null); }
                            }
                        }).catch(err => console.error(err));
                }
            }

            function processSpeechText() { 
                speechText.style.fontSize = '100px'; // Default font size
                resizeSpeechTextToFit();
            }

            function resizeSpeechTextToFit() {
                try {
                    let fontSize = window.getComputedStyle(speechText).fontSize;
                    speechText.style.fontSize = (parseFloat(fontSize) - 1) + 'px';

                    if (speechText.clientHeight >= speechTextContainer.clientHeight) {
                        resizeSpeechTextToFit();
                    }
                } catch (err) { }
            }
            
            function changeSpeechTextContainerBackround(fromClassPrefix, toClassPrefix) {
                speechTextContainer.classList.remove(fromClassPrefix + "TTSBackground");
                speechTextContainer.classList.add(toClassPrefix + "TTSBackground");
                if (toClassPrefix == "butler") {
                    speechText.style.backdropFilter = "blur(3px)";
                    speechText.style.webkitBackdropFilter = "blur(3px)";
                } else {
                    speechText.style.backdropFilter = "";
                    speechText.style.webkitBackdropFilter = "";
                }
            }

            function playTTSAudio(ttsAudioSource, changeBackground, fromClassPrefix, toClassPrefix) {
                var speechAudio = new Audio(ttsAudioSource);
                speechAudio.addEventListener("ended", function() {
                    speechTextContainer.classList.toggle('fade');
                    setTimeout(function() {
                        if (changeBackground && fromClassPrefix && toClassPrefix) { changeSpeechTextContainerBackround(fromClassPrefix, toClassPrefix); }
                        endProcessing();
                    }, 1000);
                });
                var speechPlayPromise = speechAudio.play();
                if (speechPlayPromise !== undefined) {
                    speechPlayPromise.then(_ => {
                        // Autoplay started!
                    }).catch(error => {
                        // Autoplay was prevented.
                        console.error(error);
                        speechTextContainer.classList.toggle('fade');
                        setTimeout(function() {
                            if (changeBackground && fromClassPrefix && toClassPrefix) { changeSpeechTextContainerBackround(fromClassPrefix, toClassPrefix); }
                            endProcessing();
                        }, 1000);
                    });
                }
            }

            function resolveSubAlertTTS(subMessage) {
                // Retrieve Voice Name from the Sub Message
                var voiceName = extractVoiceName(subMessage);
                
                // Set the available Voice Names based on Bot
                var availableVoiceNames = isBot ? allVoiceNames : unrestrictedVoiceNames;
                    
                // Initialize Necessary Variables for Voice
                var voiceID = null;
                var voiceSettings = "";
                var modelID = "";
                
                // Perform Voice Name checks and Voice Retrieval if not "juli"
                if (voiceName != "juli") {
                    var voice;
                    
                    // Check if Voice Name is an available choice or "random" 
                    if (voiceName == "default" || voiceName == "random" || !availableVoiceNames.includes(voiceName)) {
                        voiceName = availableVoiceNames[(Math.floor(Math.random() * availableVoiceNames.length))];
                        voice = voices[voiceName];
                    } else { voice = voices[voiceName]; }
                    
                    // Set Voice values accordingly
                    voiceID = voice.voice_id;
                    voiceSettings = voice.voice_settings;
                    modelID = voice.model_id;
                    voiceVolume = voice.voice_volume;

                    // If Voice has different dialogue endings, add one to the end of the Message
                    if (voice.dialogue_endings.length != 0) {
                        endingDialogue = voice.dialogue_endings[(Math.floor(Math.random() * voice.dialogue_endings.length))];
                        subMessage += endingDialogue;
                    }
                } else { voiceID = voiceName; }
                
                // Check Voice ID
                if (voiceID) {
                    // Remove any cheers and voice name (including brackets) from the bits message
                    let voiceText = removeCheerWords(subMessage).replace('[' + voiceName + ']','').replace('[random]','').trim();

                    if (voiceText) {
                        // Convert the above text to speech using the indicated voice
                        initiateTTS(false, voiceID, voiceSettings, voiceText, modelID);
                    } else {
                        // Handle the case where there is no message
                        console.log("No message for TTS.");
                        endProcessing();
                    }
                } else {
                    // Handle the case where name matches no id
                    console.error("No ID found for voice name.");
                    endProcessing();
                }
            }

            function addBotBackgroundCSS(botName, botBackgroundImageURL) {
                const style = document.createElement("style");
                style.innerHTML = "." + botName + "TTSBackground { " + 
                    "background: url('" + botBackgroundImageURL + "') center no-repeat transparent; " + 
                    "background-size: cover; " + 
                    "background-position-y: top; " + 
                "}";
                document.head.appendChild(style);
            }

            function createPercentageBasedArray(entryPercentList) {
                let resultArray = [];

                entryPercentList.forEach(item => {
                    let { entry, percentage } = item;
                    // Calculate the number of times the 'entry' should appear, based on percentage of 100
                    let count = Math.round((percentage / 100) * 100);
                    resultArray.push(...Array(count).fill(entry));
                });

                // Adjust the array to ensure it has exactly 100 items
                if (resultArray.length > 100) {
                    resultArray = resultArray.slice(0, 100);
                } else if (resultArray.length < 100) {
                    let deficit = 100 - resultArray.length;
                    // If the array is too short, fill the remaining slots with the first entry in the list
                    resultArray.push(...Array(deficit).fill(entryPercentList[0].name));
                }

                return resultArray;
            }
        </script>

    </body>

</html>
