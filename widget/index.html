<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, shrink-to-fit=no">
        <title>AI Voice TTS - Widget</title>

        <!-- Favicon -->
        <link rel="icon" type="image/png" href="../assets/images/logo/favicon_120x120.png">
        <link rel="apple-touch-icon" href="../assets/images/logo/favicon_120x120.png">

        <!-- page css -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/select2-bootstrap-5-theme@1.3.0/dist/select2-bootstrap-5-theme.min.css" />
        
        <!-- Core css -->
        <link href="../assets/css/app.min.css" rel="stylesheet">
        <link rel="stylesheet" media="all" type="text/css" href="../assets/vendors/fontawesome/css/font-awesome-5-all.min.css" />
        
        <!-- page js -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>

        <!-- custom css -->
        <style>
            html, body {
                background-color: transparent;
                overflow-x: hidden;
            }
            #alertBox {
                opacity: 1;
                transition: opacity 1s; 
            }
            #alertBox.fade {
                opacity: 0;
            }
            .normalTTSBackground {
                background: url('../assets/images/rgb-audio-wave-animation.gif') center no-repeat transparent;
                background-size: cover;
            }
            .juliBanTTSBackground {
                background: url('../assets/images/rear-view-of-police-cars-chasing.gif') center no-repeat transparent;
                background-size: cover;
            }
        </style>
    </head>

    <body>
        <!-- Loading START -->
        <div id="page-loading" class="d-none align-items-center justify-content-center position-absolute w-100 h-100" style="z-index:3000;">
            <div class="spinner-border" role="status">
                <span class="sr-only">Loading...</span>
            </div>
        </div>
        <!-- Loading END -->

        <!-- Content START -->
        <div id="page-content">
            <div class="normalTTSBackground fade" id="alertBox" style="width: 100%;height: 100vw;">
                <div class="row d-flex justify-content-center align-items-center bd-highlight h-100">
                    <font class="text-center text-white" id="speechText" style="text-shadow: rgb(0, 0, 0) 3px 3px 0px, rgb(0, 0, 0) -1px -1px 0px, rgb(0, 0, 0) 1px -1px 0px, rgb(0, 0, 0) -1px 1px 0px, rgb(0, 0, 0) 1px 1px 0px;">[Speech Text Goes Here]</font>
                </div>
            </div>
        </div>
        <!-- Content END -->

        <!-- Core Vendors JS -->
        <script src="../assets/js/vendors.min.js"></script>
        
        <!-- page js -->
        <script async defer src="https://apis.google.com/js/api.js"></script>
        
        <!-- Core JS -->
        <script src="../assets/js/app.min.js"></script>

        <!-- Custom JS -->
        <script src='https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js' type='text/javascript'></script>
        <script type="text/javascript">
            
            // Initialize Global Variables
            var appID = null;
            var developerKey = null;
            var userInfoSheetID = null;
            var adminAccessToken = null;
            var userInfoValues = null;
            var userID = null;
            var userName = null;
            var userSLToken = null;
            var userELToken = null;
            var userOAToken = null;
            var userBotBackgroundImageURL = "../assets/images/bot-butler_placeholder.png";
            var userBotInstructions = "";
            var userLawyerInstructions = "";
            var userNoirInstructions = "";
            var userKimInstructions = "Take the following line(s) of dialogue and modify the spelling so they will sound like they are being spoken with a French accent when read aloud by a text-to-speech system. Use slightly phonetic spelling to reflect a natural-sounding French accent, but keep the meaning clear and don't over-exaggerate. Reply with only the modified line(s), nothing else.";
            var userKeyString = "";
            var userAppClientID = "";
            var userTwitchID = "";
            var twitchAccessToken = null;
            var channelPointRewardID = "";
            var cheerWords;
            var twitchUserName = "Anonymous";
            
            var hasBackgroundMusic = false;
            var backgroundMusicAudio;
            const alertAudioSource = "../assets/audio/twitch-bits-donation-sound-effect-sfx.mp3";

            var isBot = false;
            const fillerAudioList = [
                {entry: "../assets/audio/filler/knocking-and-door-opening.mp3", percentage: 50},
                {entry: "../assets/audio/filler/three-gentle-knocks.mp3", percentage: 30},
                {entry: "../assets/audio/filler/throat-clear-with-spoken-knock.mp3", percentage: 20}
            ];
            const fillerAudios = createPercentageBasedArray(fillerAudioList);
            var endingDialogue = "";
            
            var voices;
            var allVoiceNames;
            var unrestrictedVoiceNames;
            var standardVoiceNames;
            const premiumVoiceBitsAmount = 500;
            var voiceVolume = 1.0;

            // Prep Event Queue
            const eventQueue = [];
            let isProcessing = false;

            function processEventQueue() {
                if (isProcessing || eventQueue.length === 0) {
                    return;
                }

                isProcessing = true;
                const event = eventQueue.shift();
                handleEvent(event);
            }

            function handleEvent(event) {
                return new Promise((resolve, reject) => {
                    try {
                        const eventHandlers = [];
                        // Determine Streamlabs or Twitch EventSub
                        if (event.for) {
                            eventHandlers.push(handleStreamLabsTwitchEvent(event));
                        } else {
                            eventHandlers.push(handleTwitchEventNotification(event));
                        }
                        
                        // Pass the different handlers
                        Promise.all(eventHandlers)
                        .then(resolve)
                        .catch(reject);
                    } catch (error) {
                        reject(error);
                        endProcessing();
                    }
                });
            }

            function endProcessing() {
                if (hasBackgroundMusic) {
                    backgroundMusicAudio.pause();
                    hasBackgroundMusic = false;
                }
                isProcessing = false;
                processEventQueue(); // Process the next event in the queue
            }
            
            $(document).ready(function() {
                processSpeechText();
                window.addEventListener('resize', processSpeechText);

                const urlParams = new URLSearchParams(window.location.search);
                userID = urlParams.get('u') || null;

                if (!userID) {
                    console.error('Invalid or missing User ID.');
                    alert('Error 400.');
                    return;
                }

                // Show/hide loading animation on page load/unload
                window.onpageshow = () => toggleLoadingDisplay(false);
                window.onbeforeunload = () => toggleLoadingDisplay(true);

                loadJSONFiles([
                    '../voices.json',
                    '../settings.json'
                ]).then(([voicesData, settingsData]) => {
                    setupVoiceData(voicesData);
                    processAppSettings(settingsData);
                }).catch(err => {
                    console.error('Error loading JSON files:', err);
                    alert('App Settings Error!');
                });

                function toggleLoadingDisplay(isLoading) {
                    $("#page-content").toggle(!isLoading);
                    $("#page-loading").toggleClass("d-flex", isLoading).toggleClass("d-none", !isLoading);
                }

                async function loadJSONFiles(paths) {
                    return await Promise.all(paths.map(path => $.getJSON(path)));
                }

                function setupVoiceData(data) {
                    voices = data;
                    allVoiceNames = Object.keys(voices);
                    unrestrictedVoiceNames = allVoiceNames.filter(name => name !== "butler");
                    standardVoiceNames = unrestrictedVoiceNames.filter(name => name !== "mayor");
                }

                function processAppSettings(data) {
                    appID = data.googleCloudAppCredentials.appID;
                    developerKey = data.googleCloudAppCredentials.apiKey;
                    userInfoSheetID = data.googleDriveDataLocations.userInfoSheetID;
                    cheerWords = data.appValues.cheerWords;

                    manageAccessToken(data.googleCloudAppCredentials.client_id, data.googleCloudAppCredentials.client_secret, data.googleCloudAppCredentials.refresh_token).then(() => {
                        loadSheetReadingClient();
                    }).catch(err => {
                        console.error('Unable to retrieve or refresh Access Token.', err);
                    });
                }

                async function manageAccessToken(client_id, client_secret, refresh_token) {
                    let expiration = null;
                    try {
                        expiration = parseInt(sessionStorage.getItem("adminAccessTokenExpiration"));
                        if ((Date.now()/1000) > expiration - 300) {
                            console.log('Google Access Token in Session is expired.');

                            // If the Access Token is expired, remove the expiration (and try to remove the access token) from the session
                            sessionStorage.removeItem("adminAccessTokenExpiration");
                            try { sessionStorage.removeItem("adminAccessToken"); }
                            catch (err) { }
                        } else { adminAccessToken = sessionStorage.getItem("adminAccessToken"); }
                    } catch (err) { console.log('Unable to retrieve Google Access Token from Session.\n' + err); }
                    if (!adminAccessToken) {
                        console.log('Refreshing Access Token...');
                        var newTokenData = await refreshAccessToken(client_id, client_secret, refresh_token);
                        adminAccessToken = newTokenData.access_token;
                        sessionStorage.setItem("adminAccessToken", adminAccessToken);
                        sessionStorage.setItem("adminAccessTokenExpiration", (Date.now() / 1000) + newTokenData.expires_in);
                    }
                }
            });

            function refreshAccessToken(clientID, clientSecret, refreshToken) {
                return new Promise(function(resolve, reject) {
                    $.ajax({
                        url: 'https://accounts.google.com/o/oauth2/token',
                        data: {
                            client_id: clientID,
                            client_secret: clientSecret,
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        },
                        type: 'POST',
                        dataType: 'json',
                        success: function(responseData) {
                            resolve(responseData);
                        },
                        error: function(err) {
                            reject(err);
                        }
                    });
                });
            }

            function loadSheetReadingClient() {
                gapi.load('client', initializeSheetReadingClient);
            }
            
            function initializeSheetReadingClient() {
                gapi.client.init({
                    apiKey: developerKey,
                    discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
                }).then(() => {
                    console.log('Reading database...');
                    getUserInfo(userID);
                });
            }

            // Searches for User ID in database and sets user info variables
            function getUserInfo(userID) {
                gapi.client.request({
                    path: 'https://content-sheets.googleapis.com/v4/spreadsheets/' + userInfoSheetID + '/values/Sheet1!A2:M',
                    method: 'GET',
                    headers: {
                        Authorization: 'Bearer ' + adminAccessToken,
                    },
                }).then((response) => {
                    const values = response.result.values;
                    if (values && values.length > 0) {
                        console.log('Database read successfully!');

                        var userInfoIndex = findIndex(values, userID);
                        if (userInfoIndex[0] != -1 && userInfoIndex[1] == 0) {
                            console.log('User Info found!');
                            userInfoValues = [
                                values[userInfoIndex[0]][0],
                                values[userInfoIndex[0]][1],
                                values[userInfoIndex[0]][2],
                                values[userInfoIndex[0]][3],
                                values[userInfoIndex[0]][4],
                                values[userInfoIndex[0]][5],
                                values[userInfoIndex[0]][6],
                                values[userInfoIndex[0]][7],
                                values[userInfoIndex[0]][8],
                                values[userInfoIndex[0]][9],
                                values[userInfoIndex[0]][10],
                                values[userInfoIndex[0]][11],
                                values[userInfoIndex[0]][12]
                            ];
                            userName = userInfoValues[1];
                            userSLToken = userInfoValues[2];
                            userELToken = userInfoValues[3];
                            userOAToken = userInfoValues[4];
                            userBotInstructions = userInfoValues[6];
                            userKeyString = userInfoValues[7];
                            userAppClientID = userInfoValues[8];
                            userTwitchID = userInfoValues[9];
                            channelPointRewardID = userInfoValues[10];
                            userLawyerInstructions = userInfoValues[11];
                            userNoirInstructions = userInfoValues[12];

                            // Bot Background Image
                            if (userInfoValues[5]) { userBotBackgroundImageURL = userInfoValues[5]; }
                            addBotBackgroundCSS('butler', userBotBackgroundImageURL);

                            // Connect to socket
                            const streamlabs = io(`https://sockets.streamlabs.com?token=${userSLToken}`, {transports: ['websocket']});
                            console.log('Listening on Streamlabs...');

                            // Perform Action on event
                            streamlabs.on('event', (eventData) => {
                                if (eventData.for === 'twitch_account') {
                                    eventQueue.push(eventData);
                                    processEventQueue(); // Start processing the queue
                                }
                            });

                            // Connect to 
                            connectToTwitchEventSub();
                        } else {
                            // Handle the case were no match is found in the first column
                            console.error('User not found! Index: ' + userInfoIndex);
                            alert('Database Error 404.');
                        }
                    } else {
                        console.error('No values found!');
                        alert('Database Error 204.');
                    }
                }).catch((error) => {
                    console.error('Error reading values:', error);
                    alert('Database Error 500.');
                });
            }

            // Method to return an array of indices of keyString
            function findIndex(stringArray, keyString) {
                // Initialising result array to -1 in case keyString is not found
                let result = [-1, -1];
            
                // Iteration over all the elements of the 2-D array
                // Rows
                for (let r = 0; r < stringArray.length; r++) {
            
                    // Columns
                    for (let c = 0; c < stringArray[r].length; c++) {
            
                        // If keyString is found
                        if (stringArray[r][c] == keyString) {
                            result[0] = r;
                            result[1] = c;
                            return result;
                        }
                    }
                }
            
                // If keyString is not found then -1 is returned
                return result;
            }

            // Function to get a Twitch OAuth token
            async function getTwitchOAuthToken() {
                const response = await fetch('https://app.aivoicetts.com/GetTwitchAccessToken?id=' + userKeyString, {
                    method: 'POST'
                });

                const data = await response.text();
                twitchAccessToken = data;
                sessionStorage.setItem("twitchAccessToken", twitchAccessToken);
                return data;
            }

            // Function to validate a Twitch Access Token
            async function validateTwitchToken(accessToken) {
                const validationUrl = 'https://id.twitch.tv/oauth2/validate';

                if (accessToken) {
                    try {
                        const response = await fetch(validationUrl, {
                            method: 'GET',
                            headers: {
                                'Authorization': 'OAuth ' + accessToken
                            }
                        });

                        if (response.ok) {
                            console.log('Twitch Access Token is valid.');
                            return true;
                        } else {
                            console.warn('Twitch Access Token is invalid or expired.');
                            sessionStorage.removeItem("twitchAccessToken");
                            return false;
                        }
                    } catch (error) {
                        console.error('Error validating token:', error);
                        sessionStorage.removeItem("twitchAccessToken");
                        return false;
                    }
                } else {
                    console.log('No saved Twitch Access Token found.');
                    return false;
                }
            }

            // Function to ensure a valid Twitch Access Token
            async function ensureValidTwitchToken(accessToken) {
                const isValid = await validateTwitchToken(accessToken);

                if (!isValid) {
                    console.log('Fetching a new Twitch Access Token...');
                    try {
                        const newAccessToken = await getTwitchOAuthToken();
                        console.log('New Twitch Access Token obtained.');
                        return newAccessToken;
                    } catch (error) {
                        console.error('Error fetching new Twitch Access Token:', error);
                        throw error;
                    }
                }

                return accessToken;
            }

            // Connect to Twitch EventSub WebSocket
            const connectToTwitchEventSub = () => {
                const socket = new WebSocket("wss://eventsub.wss.twitch.tv/ws");

                socket.onopen = () => {
                    console.log("WebSocket connection established.");
                };

                socket.onmessage = async (event) => {
                    const message = JSON.parse(event.data);

                    if (message.metadata?.message_type === "session_welcome") {
                        console.log("Twitch API Session Established:", message.payload.session);
                        const sessionId = message.payload.session.id;
                        await subscribeToEvents(sessionId);
                    } else if (message.metadata?.message_type === "notification") {
                        eventQueue.push(message.payload);
                        processEventQueue(); // Start processing the queue
                    }
                };

                socket.onerror = (error) => {
                    console.error("WebSocket error:", error);
                };

                socket.onclose = (event) => {
                    console.log("WebSocket closed:", event);
                    // Optionally implement reconnection logic here
                    //console.log('WebSocket closed. Attempting to reconnect...');
                    setTimeout(connectToTwitchEventSub, 5000);
                };

                return socket;
            };

            // Subscribe to the required events
            const subscribeToEvents = async (sessionId) => {
                const url = "https://api.twitch.tv/helix/eventsub/subscriptions";

                const events = [
                    {
                        type: "channel.channel_points_custom_reward_redemption.add",
                        condition: { broadcaster_user_id: userTwitchID }
                    }
                ];

                for (const event of events) {
                    const payload = {
                        ...event,
                        version: "1",
                        transport: {
                            method: "websocket",
                            session_id: sessionId,
                        },
                    };

                    const oauthToken = await ensureValidTwitchToken(twitchAccessToken);

                    const headers = {
                        "Client-ID": userAppClientID,
                        Authorization: 'Bearer ' + oauthToken,
                        "Content-Type": "application/json",
                    };

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers,
                            body: JSON.stringify(payload),
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            console.error(`Failed to subscribe to ${event.type}:`, errorData);
                        } else {
                            const responseData = await response.json();
                            console.log(`Subscription to ${event.type} successful:`, responseData);
                        }
                    } catch (error) {
                        console.error(`Error subscribing to ${event.type}:`, error);
                    }
                }
            };

            // Handle incoming event notifications
            const handleTwitchEventNotification = (eventNotification) => {
                return new Promise((resolve, reject) => {
                    const eventType = eventNotification.subscription.type;
                    const eventData = eventNotification.event;
                    switch (eventType) {
                        case "channel.channel_points_custom_reward_redemption.add":
                            //console.log("Channel Point Redemption:", eventData);
                            if (eventData.reward.id === channelPointRewardID) {
                                // Save Username
                                try { 
                                    twitchUserName = eventData.user_name; 
                                } catch (err) {
                                    console.log("Unable to read name from Event.", err);
                                    twitchUserName = "Anonymous"; // Reset back to "Anonymous", just in case
                                }
                                resolveChannelPointTTS(100, eventData.user_input.replace(/"/g, '').replace(/[“”]/g, '').replace(/[‘’]/g, ''));
                            } else { endProcessing(); }
                            resolve("Channel Point Redemption processed");
                            break;
                        default:
                            // Failsafe?
                            resolve("Do Nothing.");
                            endProcessing();
                    }
                });
            };

            function handleStreamLabsTwitchEvent(eventData) {
                return new Promise((resolve, reject) => {
                    try {
                        //console.log(JSON.stringify(eventData));
                        if (eventData.type == "bits") {
                            console.log("Twitch Bits/Cheer Event!");
                            isBot = false;

                            // Save Username of Cheerer
                            twitchUserName = eventData.message[0]?.name || "Anonymous";

                            // Check if Preview or Test Alert
                            const isPreview = eventData.message[0]?.isPreview || false;
                            const isTest = eventData.message[0]?.isTest || false;

                            if (!isPreview) {
                                const bitsAmount = parseInt(eventData.message[0]?.amount) || 0;
                                if (isTest) {
                                    console.log("Received Test Alert.");
                                    console.log(eventData.message);
                                    if (bitsAmount >= premiumVoiceBitsAmount) {
                                        resolveCheerAlertTTS(bitsAmount, "[mayor] " + eventData.message[0].message.replace(/"/g, '').replace(/[“”]/g, '').replace(/[‘’]/g, ''));
                                    } else if (parseInt(eventData.message[0].amount) >= 1) {
                                        resolveCheerAlertTTS(bitsAmount, "[hifumi] " + eventData.message[0].message.replace(/"/g, '').replace(/[“”]/g, '').replace(/[‘’]/g, ''));
                                    }
                                } else {
                                    if (bitsAmount >= 1) {
                                        resolveCheerAlertTTS(bitsAmount, eventData.message[0].message.replace(/"/g, '').replace(/[“”]/g, '').replace(/[‘’]/g, ''));
                                    }
                                }
                            }
                            resolve(`Bits Event processed for ${twitchUserName}`);
                        } else if (eventData.type == "subscription" || eventData.type == "resub") {
                            console.log("Twitch Sub Event!");
                            // Save Username of Subscriber
                            twitchUserName = eventData.message[0]?.name || "Anonymous";
                            try {
                                if (eventData.message[0].message) {
                                    isBot = false;
                                    setTimeout(function() {
                                        resolveSubAlertTTS(eventData.message[0].message.replace(/"/g, '').replace(/[“”]/g, '').replace(/[‘’]/g, ''));
                                    }, 3000);
                                } else {
                                    if (eventData.message[0].subscriber_name) {
                                        console.log("Triggered from Mass Gifting. Ignoring...");
                                        endProcessing();
                                    } else {
                                        if (eventData.message[0].gifter) {
                                            console.log("Single Gifted Sub! Activating Bot...");
                                            isBot = true;
                                            setTimeout(function() { prepForBot() }, 3000);

                                            sendMessageToBot("\"" + eventData.message[0].gifter + "\" just gifted a Twitch sub to \"" + twitchUserName + "\"");
                                        } else {
                                            console.log("No Sub Message. Activating Bot...");
                                            isBot = true;
                                            setTimeout(function() { prepForBot() }, 3000);

                                            let months = parseInt(eventData.message[0].months);
                                            sendMessageToBot("\"" + twitchUserName + "\" just " + (months > 0 ? "resubscribed on Twitch" : "subscribed on Twitch for the very first time"));
                                        }
                                    }
                                }
                            } catch (err) {
                                console.log("Unable to read message from Event.", err);
                                endProcessing();
                            }
                            resolve(`Sub Event processed for ${twitchUserName}`);
                        } else if (eventData.type == "subMysteryGift") {
                            console.log("Twitch Mass Gifted Sub Event! Activating Bot...");
                            try {
                                isBot = true;
                                setTimeout(function() { prepForBot() }, 3000);

                                let amount = parseInt(eventData.message[0].amount);
                                sendMessageToBot("\"" + eventData.message[0].gifter + "\" just gifted " + eventData.message[0].amount + " Twitch sub" + (amount == 1 ? "" : "s") + " to the community");
                            } catch (err) {
                                console.log("Unable to activate.", err);
                                endProcessing();
                            }
                            resolve(`Sub Event processed`);
                        } else {
                            // Failsafe?
                            resolve("Do Nothing.");
                            endProcessing();
                        }
                    } catch (error) {
                        reject(error);
                        endProcessing();
                    }
                });
            }

            function resolveChannelPointTTS(channelPointAmount, channelPointMessage) {
                // Retrieve Voice Name from the Channel Point Message
                var voiceName = extractVoiceName(channelPointMessage);
                
                // Set the available Voice Names based on Amount
                var availableVoiceNames = (channelPointAmount >= premiumVoiceBitsAmount ? unrestrictedVoiceNames : standardVoiceNames);
                    
                // Initialize Necessary Variables for Voice
                var voiceID = null;
                var voiceSettings = "";
                var modelID = "";

                // Perform Voice Name checks and Voice Retrieval if not "juli"
                if (voiceName != "juli") {
                    // Have AI rewrite the message and takeover TTS if the Voice Name is "lawyer", "noir", or "kim"
                    if (voiceName == "lawyer" || voiceName == "noir" || voiceName == "kim") {
                        rewriteMessageUsingAI(voiceName, channelPointMessage);
                        return;
                    } else {
                        var voice;
                        
                        // Check if Voice Name is an available choice or "random" 
                        if (voiceName == "random") {
                            voiceName = availableVoiceNames[(Math.floor(Math.random() * availableVoiceNames.length))];
                            voice = voices[voiceName];
                        } else if (!availableVoiceNames.includes(voiceName)) {
                            console.log("Voice Name \"" + voiceName + "\" NOT an available choice.")
                            voice = voices["will"];
                        } else { voice = voices[voiceName]; }
                        
                        // Set Voice values accordingly
                        voiceID = voice.voice_id;
                        voiceSettings = voice.voice_settings;
                        modelID = voice.model_id;
                        voiceVolume = voice.voice_volume;

                        // If Voice has different dialogue endings, add one to the end of the Message
                        if (voice.dialogue_endings.length != 0) {
                            endingDialogue = voice.dialogue_endings[(Math.floor(Math.random() * voice.dialogue_endings.length))];
                            channelPointMessage += endingDialogue;
                        }
                    }
                } else { voiceID = voiceName; }
                
                // Check Voice ID
                if (voiceID) {
                    // Remove any cheers and voice name (including brackets) from the bits message
                    let voiceText = removeCheerWords(channelPointMessage).replace('[' + voiceName + ']','').replace('[random]','').trim();

                    if (voiceText) {
                        // Convert the above text to speech using the indicated voice
                        initiateTTS(true, voiceID, voiceSettings, voiceText, modelID);
                    } else {
                        // Handle the case where there is no message
                        console.log("No message for TTS.");
                        endProcessing();
                    }
                } else {
                    // Handle the case where name matches no id
                    console.error("No ID found for voice name.");
                    endProcessing();
                }
            }

            function resolveCheerAlertTTS(bitsAmount, bitsMessage) {
                // Retrieve Voice Name from the Bits Message
                var voiceName = extractVoiceName(bitsMessage);
                
                // Set the available Voice Names based on Bits Amount
                var availableVoiceNames = (bitsAmount >= premiumVoiceBitsAmount ? unrestrictedVoiceNames : standardVoiceNames);
                    
                // Initialize Necessary Variables for Voice
                var voiceID = null;
                var voiceSettings = "";
                var modelID = "";

                // Perform Voice Name checks and Voice Retrieval if not "juli"
                if (voiceName != "juli") {
                    // Have AI rewrite the message and takeover TTS if the Voice Name is "lawyer", "noir", or "kim"
                    if (voiceName == "lawyer" || voiceName == "noir" || voiceName == "kim") {
                        rewriteMessageUsingAI(voiceName, bitsMessage);
                        return;
                    } else {
                        var voice;
                        
                        // Check if Voice Name is an available choice or "random" 
                        if (voiceName == "random") {
                            voiceName = availableVoiceNames[(Math.floor(Math.random() * availableVoiceNames.length))];
                            voice = voices[voiceName];
                        } else if (!availableVoiceNames.includes(voiceName)) {
                            console.log("Voice Name \"" + voiceName + "\" NOT an available choice.")
                            voice = voices["will"];
                        } else { voice = voices[voiceName]; }
                        
                        // Set Voice values accordingly
                        voiceID = voice.voice_id;
                        voiceSettings = voice.voice_settings;
                        modelID = voice.model_id;
                        voiceVolume = voice.voice_volume;

                        // If Voice has different dialogue endings, add one to the end of the Message
                        if (voice.dialogue_endings.length != 0) {
                            endingDialogue = voice.dialogue_endings[(Math.floor(Math.random() * voice.dialogue_endings.length))];
                            bitsMessage += endingDialogue;
                        }
                    }
                } else { voiceID = voiceName; }
                
                // Check Voice ID
                if (voiceID) {
                    // Remove any cheers and voice name (including brackets) from the bits message
                    let voiceText = removeCheerWords(bitsMessage).replace('[' + voiceName + ']','').replace('[random]','').trim();

                    if (voiceText) {
                        // Convert the above text to speech using the indicated voice
                        initiateTTS(true, voiceID, voiceSettings, voiceText, modelID);
                    } else {
                        // Handle the case where there is no message
                        console.log("No message for TTS.");
                        endProcessing();
                    }
                } else {
                    // Handle the case where name matches no id
                    console.error("No ID found for voice name.");
                    endProcessing();
                }
            }

            function extractVoiceName(message) {
                const match = message.match(/\[([^\]]+)\]/);
                return match ? match[1].toLowerCase() : "default";
            }

            function removeCheerWords(eventMessage) {
                // Create a regex to match any cheer words followed by digits
                const regex = new RegExp(cheerWords.map(word => `${word}\\d+`).join('|'), 'gi');
                return eventMessage.replace(regex, '');
            }

            async function rewriteMessageUsingAI(character, message) {
                const apiUrl = "https://api.openai.com/v1/chat/completions";
                const headers = {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${userOAToken}`
                };

                const preppedUserMessage = removeCheerWords(message).replace('[' + character + ']','').replace(/"/g, '').replace(/[“”]/g, '').replace(/[‘’]/g, '').trim();

                let userCharacterInstructions = "";
                let messageToAI = "";
                if (character == "noir") {
                    userCharacterInstructions = userNoirInstructions;
                    messageToAI = "The statement you should turn into a short monologue is in the following french brackets: {" + preppedUserMessage + "}";
                    hasBackgroundMusic = true;
                    backgroundMusicAudio = new Audio("../assets/audio/noir_dark-night-jazz-background-music.mp3");
                    var backgroundMusicPlayPromise = backgroundMusicAudio.play();
                    if (backgroundMusicPlayPromise !== undefined) {
                        backgroundMusicPlayPromise.then(_ => {
                            fadeAudio(backgroundMusicAudio, 'in', 2000, 0.25);
                        }).catch(error => {
                            hasBackgroundMusic = false;
                            console.error(error);
                        });
                    }
                } else if (character == "kim") {
                    userCharacterInstructions = userKimInstructions;
                    messageToAI = "Lines:\n" + preppedUserMessage;
                } else {
                    userCharacterInstructions = userLawyerInstructions;
                    messageToAI = "Your client's Twitch username is \"" + twitchUserName + "\" and the message they just gave you is in the following french brackets: {" + preppedUserMessage + "}";
                }

                const data = {
                    model: "gpt-4o",
                    messages: [
                        { role: "system", content: userCharacterInstructions },
                        { role: "user", content: messageToAI }
                    ]
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: headers,
                        body: JSON.stringify(data)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Error: ${response.status}`);
                    }

                    const responseData = await response.json();

                    // Remove any quotation marks and replace line breaks with spaces to prevent any TTS issues
                    resolveAIRewrittenTTS("[" + character + "] " + responseData.choices[0].message.content.replace(/"/g, '').replace(/\n/g, " "));
                } catch (error) {
                    console.error("Error sending message: ", error);
                    endProcessing();
                }
            }

            function resolveAIRewrittenTTS(rewrittenMessage) {
                // Retrieve Voice Name from the Rewritten Message
                var voiceName = extractVoiceName(rewrittenMessage);
                
                // Initialize and set Voice values accordingly
                var voice = voices[voiceName];
                var voiceID = voice.voice_id;
                var voiceSettings = voice.voice_settings;
                var modelID = voice.model_id;
                voiceVolume = voice.voice_volume;

                // If Voice has different dialogue endings, add one to the end of the Message
                if (voice.dialogue_endings.length != 0) {
                    endingDialogue = voice.dialogue_endings[(Math.floor(Math.random() * voice.dialogue_endings.length))];
                    rewrittenMessage += endingDialogue;
                }
                
                // Check Voice ID
                if (voiceID) {
                    // Remove any cheers and voice name (including brackets) from the message
                    let voiceText = removeCheerWords(rewrittenMessage).replace('[' + voiceName + ']','').trim();

                    if (voiceText) {
                        // Convert the above text to speech using the indicated voice
                        initiateTTS(!hasBackgroundMusic, voiceID, voiceSettings, voiceText, modelID);
                    } else {
                        // Handle the case where there is no message
                        console.log("No message for TTS.");
                        endProcessing();
                    }
                } else {
                    // Handle the case where name matches no id
                    console.error("No ID found for voice name.");
                    endProcessing();
                }
            }

            function prepForBot() {
                try {
                    speechText.innerHTML = "";
                    processSpeechText();
                    changeSpeechTextContainerBackround('normal', 'butler');
                    speechTextContainer.classList.remove('fade'); // Fade IN
                    
                    // Play Bot Filler Audio
                    var fillerAudio = new Audio(fillerAudios[(Math.floor(Math.random() * fillerAudios.length))]);
                    fillerAudio.play();
                } catch (error) { console.error(error); }
            }

            async function sendMessageToBot(message) {
                const apiUrl = "https://api.openai.com/v1/chat/completions";
                const headers = {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${userOAToken}`
                };

                const data = {
                    model: "gpt-4o",
                    messages: [
                        { role: "system", content: userBotInstructions },
                        { role: "user", content: message }
                    ]
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: headers,
                        body: JSON.stringify(data)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Error: ${response.status}`);
                    }

                    const responseData = await response.json();

                    // Remove any quotation marks and replace line breaks with spaces to prevent any TTS issues
                    resolveSubAlertTTS("[butler] " + responseData.choices[0].message.content.replace(/"/g, '').replace(/\n/g, " "));
                } catch (error) {
                    console.error("Error sending message: ", error);
                    endProcessing();
                }
            }
            
            const speechText = document.getElementById('speechText');
            const speechTextContainer = document.getElementById('alertBox');

            function initiateTTS(playAlertAudio, voiceID, voiceSettings, voiceText, modelID) {

                if (voiceID == "juli") {
                    speechText.innerHTML = "Time to ban " + twitchUserName + "!";
                    processSpeechText();
                    changeSpeechTextContainerBackround('normal', 'juliBan');
                    speechTextContainer.classList.remove('fade'); // Fade IN
                    if (playAlertAudio) {
                        var alertAudio = new Audio(alertAudioSource);
                        alertAudio.addEventListener("ended", function() {
                            playTTSAudio('../assets/audio/juli_yeah-thats-a-ban.mp3', true, 'juliBan', 'normal');
                        });
                        var alertPlayPromise = alertAudio.play();
                        if (alertPlayPromise !== undefined) {
                            alertPlayPromise.then(_ => {
                                // Autoplay started!
                            }).catch(error => {
                                // Autoplay was prevented.
                                console.error(error);
                                speechTextContainer.classList.add('fade'); // Fade OUT
                                setTimeout(function() {
                                    changeSpeechTextContainerBackround('juliBan', 'normal');
                                    endProcessing();
                                }, 1000);
                            });
                        }
                    } else { playTTSAudio('../assets/audio/juli_yeah-thats-a-ban.mp3', true, 'juliBan', 'normal'); }
                } else {
                    // Build options array needed for Elevenlabs API request
                    var elevenlabsOptions = {
                        method: 'POST',
                        headers: {
                            'xi-api-key': userELToken,
                            'Content-Type': 'application/json'
                        },
                        body: '{"voice_settings":' + voiceSettings + ',"text":"' + voiceText + '","model_id":"' + modelID + '"}'
                    };
                
                    fetch('https://api.elevenlabs.io/v1/text-to-speech/' + voiceID + '?enable_logging=false', elevenlabsOptions)
                        .then(res => res.blob())
                        .then(blob => {
                            speechText.innerHTML = voiceText.replace(endingDialogue,'');
                            processSpeechText();
                            if (!isBot) { speechTextContainer.classList.remove('fade'); } // Fade IN
                            if (playAlertAudio) {
                                var alertAudio = new Audio(alertAudioSource);
                                alertAudio.addEventListener("ended", function() {
                                    const url = URL.createObjectURL(blob);
                                    if (isBot) { playTTSAudio(url, true, 'butler', 'normal'); }
                                    else { playTTSAudio(url, false, null, null); }
                                });
                                var alertPlayPromise = alertAudio.play();
                                if (alertPlayPromise !== undefined) {
                                    alertPlayPromise.then(_ => {
                                        // Autoplay started!
                                    }).catch(error => {
                                        // Autoplay was prevented.
                                        console.error(error);
                                        speechTextContainer.classList.add('fade'); // Fade OUT
                                        endProcessing();
                                    });
                                }
                            } else {
                                const url = URL.createObjectURL(blob);
                                if (isBot) { playTTSAudio(url, true, 'butler', 'normal'); }
                                else { playTTSAudio(url, false, null, null); }
                            }
                        }).catch(err => console.error(err));
                }
            }

            function processSpeechText() { 
                speechText.style.fontSize = '100px'; // Default font size
                resizeSpeechTextToFit();
            }

            function resizeSpeechTextToFit() {
                try {
                    let fontSize = window.getComputedStyle(speechText).fontSize;
                    speechText.style.fontSize = (parseFloat(fontSize) - 1) + 'px';

                    if (speechText.clientHeight >= speechTextContainer.clientHeight) {
                        resizeSpeechTextToFit();
                    }
                } catch (err) { }
            }
            
            function changeSpeechTextContainerBackround(fromClassPrefix, toClassPrefix) {
                speechTextContainer.classList.remove(fromClassPrefix + "TTSBackground");
                speechTextContainer.classList.add(toClassPrefix + "TTSBackground");
            }

            function playTTSAudio(ttsAudioSource, changeBackground, fromClassPrefix, toClassPrefix) {
                var speechAudio = new Audio(ttsAudioSource);
                speechAudio.volume = voiceVolume;
                speechAudio.addEventListener("ended", function() {
                    if (hasBackgroundMusic) {
                        setTimeout(() => {
                            speechTextContainer.classList.add('fade'); // Fade OUT
                            fadeAudio(backgroundMusicAudio, 'out', 2000, 0.25);
                            setTimeout(() => {
                                backgroundMusicAudio.pause();
                                hasBackgroundMusic = false;
                                if (changeBackground && fromClassPrefix && toClassPrefix) { changeSpeechTextContainerBackround(fromClassPrefix, toClassPrefix); }
                                endProcessing();
                            }, 2000);
                        }, 1000);
                    } else {
                        speechTextContainer.classList.add('fade'); // Fade OUT
                        setTimeout(function() {
                            if (changeBackground && fromClassPrefix && toClassPrefix) { changeSpeechTextContainerBackround(fromClassPrefix, toClassPrefix); }
                            endProcessing();
                        }, 1000);
                    }
                });
                var speechPlayPromise = speechAudio.play();
                if (speechPlayPromise !== undefined) {
                    speechPlayPromise.then(_ => {
                        // Autoplay started!
                    }).catch(error => {
                        // Autoplay was prevented.
                        console.error(error);
                        speechTextContainer.classList.add('fade'); // Fade OUT
                        setTimeout(function() {
                            if (changeBackground && fromClassPrefix && toClassPrefix) { changeSpeechTextContainerBackround(fromClassPrefix, toClassPrefix); }
                            endProcessing();
                        }, 1000);
                    });
                }
            }

            function resolveSubAlertTTS(subMessage) {
                // Retrieve Voice Name from the Sub Message
                var voiceName = extractVoiceName(subMessage);
                
                // Set the available Voice Names based on Bot
                var availableVoiceNames = isBot ? allVoiceNames : unrestrictedVoiceNames;
                    
                // Initialize Necessary Variables for Voice
                var voiceID = null;
                var voiceSettings = "";
                var modelID = "";
                
                // Perform Voice Name checks and Voice Retrieval if not "juli"
                if (voiceName != "juli") {
                    var voice;
                    
                    // Check if Voice Name is an available choice or "random" 
                    if (voiceName == "default" || voiceName == "random" || !availableVoiceNames.includes(voiceName)) {
                        voiceName = availableVoiceNames[(Math.floor(Math.random() * availableVoiceNames.length))];
                        voice = voices[voiceName];
                    } else { voice = voices[voiceName]; }
                    
                    // Set Voice values accordingly
                    voiceID = voice.voice_id;
                    voiceSettings = voice.voice_settings;
                    modelID = voice.model_id;
                    voiceVolume = voice.voice_volume;

                    // If Voice has different dialogue endings, add one to the end of the Message
                    if (voice.dialogue_endings.length != 0) {
                        endingDialogue = voice.dialogue_endings[(Math.floor(Math.random() * voice.dialogue_endings.length))];
                        subMessage += endingDialogue;
                    }
                } else { voiceID = voiceName; }
                
                // Check Voice ID
                if (voiceID) {
                    // Remove any cheers and voice name (including brackets) from the message
                    let voiceText = removeCheerWords(subMessage).replace('[' + voiceName + ']','').replace('[random]','').trim();

                    if (voiceText) {
                        // Convert the above text to speech using the indicated voice
                        initiateTTS(false, voiceID, voiceSettings, voiceText, modelID);
                    } else {
                        // Handle the case where there is no message
                        console.log("No message for TTS.");
                        endProcessing();
                    }
                } else {
                    // Handle the case where name matches no id
                    console.error("No ID found for voice name.");
                    endProcessing();
                }
            }

            function addBotBackgroundCSS(botName, botBackgroundImageURL) {
                // Loads the image immediately, so it's ready when the class is called
                const img = new Image();
                img.src = botBackgroundImageURL;
                
                const style = document.createElement("style");
                style.innerHTML = "." + botName + "TTSBackground { " + 
                    "background: url('" + botBackgroundImageURL + "') center no-repeat transparent; " + 
                    "background-size: cover; " + 
                    "background-position-y: top; " + 
                "}";
                document.head.appendChild(style);
            }

            function createPercentageBasedArray(entryPercentList) {
                let resultArray = [];

                entryPercentList.forEach(item => {
                    let { entry, percentage } = item;
                    // Calculate the number of times the 'entry' should appear, based on percentage of 100
                    let count = Math.round((percentage / 100) * 100);
                    resultArray.push(...Array(count).fill(entry));
                });

                // Adjust the array to ensure it has exactly 100 items
                if (resultArray.length > 100) {
                    resultArray = resultArray.slice(0, 100);
                } else if (resultArray.length < 100) {
                    let deficit = 100 - resultArray.length;
                    // If the array is too short, fill the remaining slots with the first entry in the list
                    resultArray.push(...Array(deficit).fill(entryPercentList[0].name));
                }

                return resultArray;
            }

            var audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            function fadeAudio(audioElement, type, duration = 2000, maxVolume = 1.0) {
                if (!audioElement.gainNode) {
                    const track = audioCtx.createMediaElementSource(audioElement);
                    const gainNode = audioCtx.createGain();
                    track.connect(gainNode).connect(audioCtx.destination);
                    audioElement.gainNode = gainNode;
                }

                const gainNode = audioElement.gainNode;
                
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume(); // Resume the context if needed
                }

                const currentTime = audioCtx.currentTime;
                gainNode.gain.cancelScheduledValues(currentTime); // Cancel previous fades

                audioElement.volume = maxVolume;

                gainNode.gain.setValueAtTime(type === 'in' ? 0 : maxVolume, currentTime);
                gainNode.gain.linearRampToValueAtTime(type === 'in' ? maxVolume : 0, currentTime + duration / 1000);
            }
        </script>

    </body>

</html>
